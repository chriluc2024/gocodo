| Counter | Concept                         | Explanation                                                                                  | Demo                                                                                          |
|---------|---------------------------------|----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| 1       | Hello World                     | Basic program to print "Hello, World!"                                                       | ```go fmt.Println("Hello, World!")```                                                         |
| 2       | Values                          | Basic values and their types in Go                                                            | ```go fmt.Println("Go" + "Lang")```                                                           |
| 3       | Variables                       | Declaring and using variables                                                                 | ```go var a = "initial" fmt.Println(a)```                                                     |
| 4       | Constants                       | Declaring and using constants                                                                 | ```go const Pi = 3.14```                                                                      |
| 5       | For                             | The only looping construct in Go                                                              | ```go for i := 0; i < 10; i++ { fmt.Println(i) }```                                           |
| 6       | If/Else                         | Conditional statements                                                                        | ```go if num := 9; num < 0 { fmt.Println(num, "is negative") } else { fmt.Println(num) }```   |
| 7       | Switch                          | Multiple conditional statements                                                               | ```go switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println("Weekend") }```|
| 8       | Arrays                          | Fixed-length sequences of elements                                                            | ```go var a [5]int fmt.Println(a)```                                                          |
| 9       | Slices                          | Dynamically-sized, flexible view into the elements of an array                                | ```go s := []int{2, 3, 5, 7, 11, 13} fmt.Println(s)```                                        |
| 10      | Maps                            | Collection of key/value pairs                                                                 | ```go m := make(map[string]int) m["k1"] = 7 fmt.Println(m)```                                 |
| 11      | Range                           | Iterates over elements in a variety of data structures                                        | ```go for i, v := range s { fmt.Println(i, v) }```                                            |
| 12      | Functions                       | Grouping code into reusable blocks                                                            | ```go func add(a int, b int) int { return a + b }```                                          |
| 13      | Multiple Return Values          | Functions that return multiple values                                                         | ```go func vals() (int, int) { return 3, 7 }```                                               |
| 14      | Variadic Functions              | Functions that accept a variable number of arguments                                          | ```go func sum(nums ...int) { fmt.Println(nums) }```                                          |
| 15      | Closures                        | Functions that reference variables outside their scope                                        | ```go func intSeq() func() int { i := 0 return func() int { i++ return i } }```               |
| 16      | Recursion                       | Functions that call themselves                                                                | ```go func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1) }```                 |
| 17      | Pointers                        | Variables that store memory addresses                                                         | ```go var p *int i := 42 p = &i fmt.Println(*p)```                                            |
| 18      | Strings and Runes               | Text handling in Go                                                                           | ```go str := "Hello" fmt.Println(len(str))```                                                 |
| 19      | Structs                         | Collections of fields                                                                         | ```go type person struct { name string age int }```                                           |
| 20      | Methods                         | Functions associated with struct types                                                        | ```go func (p person) greet() string { return "Hello, " + p.name }```                         |
| 21      | Interfaces                      | Abstractions for different types                                                              | ```go type animal interface { sound() string }```                                             |
| 22      | Struct Embedding                | Including one struct in another to inherit its fields and methods                             | ```go type base struct { num int }```                                                         |
| 23      | Generics                        | Writing functions and data structures that can work with any type                             | ```go func printSlice[T any](s []T) { for _, v := range s { fmt.Println(v) } }```             |
| 24      | Errors                          | Error handling in Go                                                                          | ```go _, err := strconv.Atoi("non-int") if err != nil { fmt.Println(err) }```                 |
| 25      | Custom Errors                   | Defining custom error types                                                                   | ```go type MyError struct { msg string }```                                                   |
| 26      | Goroutines                      | Lightweight threads managed by the Go runtime                                                 | ```go go func() { fmt.Println("in goroutine") }()```                                          |
| 27      | Channels                        | Pipes that connect concurrent goroutines                                                      | ```go ch := make(chan int) go func() { ch <- 1 }()```                                         |
| 28      | Channel Buffering               | Channels with capacity to store values                                                        | ```go ch := make(chan int, 2) ch <- 1```                                                      |
| 29      | Channel Synchronization         | Synchronizing execution between goroutines                                                    | ```go done := make(chan bool) go func() { fmt.Println("done") done <- true }() <-done```      |
| 30      | Channel Directions              | Restricting channel use to send-only or receive-only                                           | ```go func ping(pings chan<- string) { pings <- "ping" }```                                   |
| 31      | Select                          | Handling multiple channel operations                                                          | ```go select { case msg := <-ch: fmt.Println(msg) }```                                        |
| 32      | Timeouts                        | Setting time limits on operations                                                             | ```go select { case <-ch: case <-time.After(time.Second): fmt.Println("timeout") }```         |
| 33      | Non-Blocking Channel Operations | Attempting channel operations without blocking                                                | ```go select { case msg := <-ch: fmt.Println(msg) default: fmt.Println("no message") }```     |
| 34      | Closing Channels                | Closing a channel to indicate that no more values will be sent                                 | ```go close(ch)```                                                                            |
| 35      | Range over Channels             | Iterating over values received from a channel                                                 | ```go for v := range ch { fmt.Println(v) }```                                                 |
| 36      | Timers                          | Representing a single event in the future                                                     | ```go timer := time.NewTimer(2 * time.Second) <-timer.C fmt.Println("Timer fired")```         |
| 37      | Tickers                         | Repeatedly triggering events at regular intervals                                             | ```go ticker := time.NewTicker(time.Millisecond * 500)```                                     |
| 38      | Worker Pools                    | Managing a group of worker goroutines                                                         | ```go jobs := make(chan int, 100)```                                                          |
| 39      | WaitGroups                      | Waiting for a collection of goroutines to finish                                              | ```go var wg sync.WaitGroup```                                                                |
| 40      | Rate Limiting                   | Controlling how frequently events are allowed to happen                                       | ```go limiter := time.Tick(time.Millisecond * 200)```                                         |
| 41      | Atomic Counters                 | Using atomic operations for safe access to shared variables                                   | ```go var ops uint64 atomic.AddUint64(&ops, 1)```                                             |
| 42      | Mutexes                         | Ensuring exclusive access to shared resources                                                 | ```go var mu sync.Mutex mu.Lock()```                                                          |
| 43      | Stateful Goroutines             | Managing state in a goroutine                                                                 | ```go type readOp struct { key int resp chan int }```                                         |
| 44      | Sorting                         | Sorting built-in and custom types                                                             | ```go sort.Ints([]int{7, 2, 4})```                                                            |
| 45      | Sorting by Functions            | Custom sorting using functions                                                                | ```go sort.Slice(people, func(i, j int) bool { return people[i].Age < people[j].Age })```     |
| 46      | Panic                           | Handling unexpected errors                                                                    | ```go panic("an error occurred")```                                                           |
| 47      | Defer                           | Ensuring a function call is performed later in the program’s execution                         | ```go defer fmt.Println("world") fmt.Println("hello")```                                      |
| 48      | Recover                         | Regaining control of a panicking goroutine                                                    | ```go defer func() { if r := recover(); r != nil { fmt.Println("Recovered", r) } }()```       |
| 49      | String Functions                | Common string operations                                                                      | ```go fmt.Println(strings.Contains("test", "es"))```                                          |
| 50      | String Formatting               | Formatting strings                                                                            | ```go fmt.Printf("pi: %v\n", 3.14)```                                                         |
| 51      | Text Templates                  | Creating and executing templates to generate formatted text                                   | ```go tmpl, _ := template.New("test").Parse("Value is {{.}}") tmpl.Execute(os.Stdout, "42")``` |
| 52      | Regular Expressions             | Matching patterns in strings                                                                  | ```go matched, _ := regexp.MatchString("p([a-z]+)ch", "peach")```                             |
| 53      | JSON                            | Encoding and decoding JSON                                                                    | ```go type Response struct { Page int } json.Marshal(&Response{Page: 1})```                   |
| 54      | XML                             | Encoding and decoding XML                                                                     | ```go type Plant struct { XMLName xml.Name `
